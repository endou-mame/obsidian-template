/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HtmlCopyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/ui/context-menu.ts
var import_obsidian = require("obsidian");

// src/converters/converters.ts
var escapeHtml = (text) => {
  const htmlEscapes = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;"
  };
  return text.replace(/[&<>"']/g, (char) => htmlEscapes[char]);
};
var convertHeadings = (text) => {
  return text.replace(
    /^(#{1,6})\s+(.+)$/gm,
    (_, hashes, content) => `<h${hashes.length}>${content}</h${hashes.length}>`
  );
};
var convertBold = (text) => {
  return text.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
};
var convertItalic = (text) => {
  let result = text.replace(/(?<!\*)_(.+?)_(?!\*)/g, "<em>$1</em>");
  result = result.replace(/(?<!\*)\*(?!\*)(.+?)(?<!\*)\*(?!\*)/g, "<em>$1</em>");
  return result;
};
var convertInlineCode = (text) => {
  return text.replace(/`(.+?)`/g, "<code>$1</code>");
};
var convertCodeBlocks = (text) => {
  return text.replace(/```(?:\w+)?\n([\s\S]*?)```/g, (_, code) => {
    return `<pre><code>${escapeHtml(code.trim())}</code></pre>`;
  });
};
var convertCode = (text) => {
  let result = convertCodeBlocks(text);
  result = convertInlineCode(result);
  return result;
};
var convertLinks = (text) => {
  return text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
};
var convertImages = (text) => {
  return text.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1">');
};
var convertLists = (text) => {
  const lines = text.split("\n");
  const result = [];
  let currentList = [];
  let listType = null;
  const flushList = () => {
    if (currentList.length > 0 && listType) {
      const tag = listType;
      result.push(`<${tag}>`);
      currentList.forEach((item) => result.push(item));
      result.push(`</${tag}>`);
      currentList = [];
      listType = null;
    }
  };
  for (const line of lines) {
    const unorderedMatch = line.match(/^(\s*)[-*]\s+(.+)$/);
    const orderedMatch = line.match(/^(\s*)\d+\.\s+(.+)$/);
    if (unorderedMatch) {
      if (listType === "ol") {
        flushList();
      }
      listType = "ul";
      currentList.push(`<li>${unorderedMatch[2]}</li>`);
    } else if (orderedMatch) {
      if (listType === "ul") {
        flushList();
      }
      listType = "ol";
      currentList.push(`<li>${orderedMatch[2]}</li>`);
    } else {
      flushList();
      result.push(line);
    }
  }
  flushList();
  return result.join("\n");
};
var convertBlockquotes = (text) => {
  const lines = text.split("\n");
  const result = [];
  let inBlockquote = false;
  let blockquoteContent = [];
  for (const line of lines) {
    if (line.startsWith("> ")) {
      if (!inBlockquote) {
        inBlockquote = true;
      }
      blockquoteContent.push(line.substring(2));
    } else {
      if (inBlockquote) {
        result.push(`<blockquote>${blockquoteContent.join("\n")}</blockquote>`);
        blockquoteContent = [];
        inBlockquote = false;
      }
      result.push(line);
    }
  }
  if (inBlockquote) {
    result.push(`<blockquote>${blockquoteContent.join("\n")}</blockquote>`);
  }
  return result.join("\n");
};
var convertTables = (text) => {
  const tableRegex = /\|(.+)\|\n\|[-:\s|]+\|\n((?:\|.+\|\n?)+)/g;
  return text.replace(tableRegex, (_, headerRow, bodyRows) => {
    const headers = headerRow.split("|").filter((cell) => cell.trim()).map((cell) => `<th>${cell.trim()}</th>`).join("\n");
    const rows = bodyRows.trim().split("\n").map((row) => {
      const cells = row.split("|").filter((cell) => cell.trim()).map((cell) => `<td>${cell.trim()}</td>`).join("\n");
      return `<tr>
${cells}
</tr>`;
    }).join("\n");
    return `<table>
<thead>
<tr>
${headers}
</tr>
</thead>
<tbody>
${rows}
</tbody>
</table>`;
  });
};
var convertParagraphs = (text) => {
  const htmlTags = /<(?:h[1-6]|ul|ol|li|blockquote|pre|table|thead|tbody|tr|th|td|img|a|strong|em|code)[^>]*>/;
  return text.split(/\n\n+/).map((paragraph) => {
    const trimmed = paragraph.trim();
    if (!trimmed || htmlTags.test(trimmed)) {
      return trimmed;
    }
    return `<p>${trimmed}</p>`;
  }).join("\n\n");
};

// src/converters/markdown-to-html.ts
var pipe = (value, ...fns) => fns.reduce((acc, fn) => fn(acc), value);
var convertMarkdownToHtml = (markdown) => {
  return pipe(
    markdown,
    convertHeadings,
    convertBold,
    convertItalic,
    convertCode,
    convertLinks,
    convertImages,
    convertLists,
    convertBlockquotes,
    convertTables,
    convertParagraphs
  );
};

// src/clipboard/clipboard.ts
var stripHtml = (html) => {
  return html.replace(/<[^>]*>/g, "");
};
var createClipboardItem = (html) => {
  const plainText = stripHtml(html);
  return new ClipboardItem({
    "text/html": new Blob([html], { type: "text/html" }),
    "text/plain": new Blob([plainText], { type: "text/plain" })
  });
};
var copyHtmlToClipboard = async (html) => {
  try {
    const clipboardItem = createClipboardItem(html);
    await navigator.clipboard.write([clipboardItem]);
  } catch (error) {
    console.error("Failed to copy to clipboard:", error);
    throw new Error("Failed to copy HTML to clipboard");
  }
};

// src/ui/context-menu.ts
var getSelectedText = (editor) => {
  const selection = editor.getSelection();
  return selection || getCurrentParagraph(editor);
};
var getCurrentParagraph = (editor) => {
  const cursor = editor.getCursor();
  const line = editor.getLine(cursor.line);
  const lines = [];
  let currentLine = cursor.line;
  while (currentLine >= 0 && editor.getLine(currentLine).trim() !== "") {
    currentLine--;
  }
  currentLine++;
  while (currentLine < editor.lineCount() && editor.getLine(currentLine).trim() !== "") {
    lines.push(editor.getLine(currentLine));
    currentLine++;
  }
  return lines.join("\n");
};
var showNotice = (message) => {
  new import_obsidian.Notice(message);
};
var handleCopyAsHtml = async (editor) => {
  try {
    const selectedText = getSelectedText(editor);
    const html = convertMarkdownToHtml(selectedText);
    await copyHtmlToClipboard(html);
    showNotice("HTML\u3068\u3057\u3066\u30B3\u30D4\u30FC\u3057\u307E\u3057\u305F");
  } catch (error) {
    console.error("Failed to copy as HTML:", error);
    showNotice("\u30B3\u30D4\u30FC\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
  }
};
var addCopyAsHtmlMenuItem = (menu, editor) => {
  menu.addItem((item) => {
    item.setTitle("HTML\u66F8\u5F0F\u3067\u30B3\u30D4\u30FC").setIcon("copy").onClick(async () => {
      await handleCopyAsHtml(editor);
    });
  });
};
var registerContextMenu = (plugin) => {
  plugin.registerEvent(
    plugin.app.workspace.on("editor-menu", (menu, editor) => {
      addCopyAsHtmlMenuItem(menu, editor);
    })
  );
};

// main.ts
var HtmlCopyPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await setupPlugin(this);
  }
  onunload() {
  }
};
var setupPlugin = async (plugin) => {
  registerCommands(plugin);
  registerContextMenu(plugin);
};
var registerCommands = (plugin) => {
  plugin.addCommand({
    id: "copy-as-html",
    name: "HTML\u66F8\u5F0F\u3067\u30B3\u30D4\u30FC",
    editorCallback: (editor, view) => {
      handleCopyCommand(editor);
    }
  });
};
var handleCopyCommand = async (editor) => {
  try {
    const selectedText = getSelectedText(editor);
    const html = convertMarkdownToHtml(selectedText);
    await copyHtmlToClipboard(html);
    showNotice("HTML\u3068\u3057\u3066\u30B3\u30D4\u30FC\u3057\u307E\u3057\u305F");
  } catch (error) {
    console.error("Failed to copy as HTML:", error);
    showNotice("\u30B3\u30D4\u30FC\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
  }
};
